from collections import defaultdict
from typing import List, Dict, Any

from .base_strategy import Strategy  # Assuming Strategy is in base_strategy.py
from src.data_process.product_state import ProductState


class StrategyExecutor:
    """
    Manages and executes multiple strategies across different products.
    It handles market data, updates product states, and triggers strategy logic.
    """

    def __init__(self):
        """
        Initializes the StrategyExecutor.
        - self.strategies: A dictionary mapping product_id to a list of strategies.
        - self.product_states: A dictionary mapping product_id to its ProductState.
        """
        self.strategies: Dict[str, List[Strategy]] = defaultdict(list)
        self.product_states: Dict[str, ProductState] = {}

    def register_strategy(self, strategy: Strategy, product_ids: List[str]) -> None:
        """
        Registers a strategy for a list of product IDs.
        If a product_id is new, its ProductState is initialized.

        Args:
            strategy: The strategy instance to register.
            product_ids: A list of product IDs for which this strategy should be active.
        """
        for product_id in product_ids:
            self.strategies[product_id].append(strategy)
            # Ensure ProductState exists for each product_id
            if product_id not in self.product_states:
                self.product_states[product_id] = ProductState(product_id=product_id)

    def get_product_state(self, product_id: str) -> ProductState:
        """
        Retrieves the ProductState for a given product_id.
        If the ProductState does not exist, it is created.

        Args:
            product_id: The identifier of the product.

        Returns:
            The ProductState instance for the given product_id.
        """
        if product_id not in self.product_states:
            self.product_states[product_id] = ProductState(product_id=product_id)
        return self.product_states[product_id]

    def on_market_data(self, product_id: str, data: Any) -> List[Any]:
        """
        Handles incoming market data for a specific product.
        It updates the product's state and then invokes all registered strategies
        for that product, collecting any generated signals.

        Args:
            product_id: The identifier of the product for which data is received.
            data: The market data (e.g., a tick, a bar).

        Returns:
            A list of signals generated by the strategies for this product and data.
        """
        product_state = self.get_product_state(product_id)
        product_state.update_market_data(data)

        all_signals = []
        if product_id in self.strategies:
            for strategy_instance in self.strategies[product_id]:
                # Ensure strategy is initialized if it has an initialize method
                if not hasattr(strategy_instance, '_initialized'): # Simple check
                    if hasattr(strategy_instance, 'initialize'):
                        strategy_instance.initialize(config={}) # Pass empty config for now
                    strategy_instance._initialized = True # Mark as initialized

                signals = strategy_instance.handle_data(product_id, data, product_state)
                if signals:  # Ensure signals list is not None and not empty
                    all_signals.extend(signals)

        # TODO: Implement actual signal processing/handling instead of just printing.
        # This might involve sending signals to an order management system, logging, etc.
        if all_signals:
            print(f"Signals for {product_id}: {all_signals}")

        return all_signals

    def run_chain_mode_for_product(self, product_id: str, data: Any) -> None:
        """
        Placeholder for Chain Mode execution logic.
        Chain Mode implies that strategies for a product might be executed sequentially,
        with the output of one strategy potentially influencing the input or state for the next.

        Args:
            product_id: The identifier of the product.
            data: The market data.

        Raises:
            NotImplementedError: This method is not yet implemented.
        """
        raise NotImplementedError("Chain mode execution is not yet implemented.")
